<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>이미지 기반 3D 복셀 지도 - 고급 광원 효과(수정본)</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #container { display: flex; flex-direction: column; height: 100vh; }
        #scene-container { flex-grow: 1; }
        #controls {
            padding: 10px; 
            background-color: #f0f0f0;
        }
        /* 폰트 크기 작게 조정 */
        #controls * {
            font-size: 10px;
        }
        #original-image { 
            position: absolute; 
            top: 10px; 
            right: 10px; 
            max-width: 200px; 
            border: 1px solid #ccc; 
            background-color: white;
            display: none;
        }
        #debug-info {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 5px;
            font-family: monospace;
            font-size: 12px;
            z-index: 100;
        }
        .position-control {
            display: flex;
            align-items: center;
            margin: 3px 0;
        }
        .position-control label {
            min-width: 50px;
            display: inline-block;
        }
        .position-control input {
            flex-grow: 1;
        }
        .position-value {
            min-width: 30px;
            text-align: right;
            margin-left: 5px;
        }
    </style>
</head>
<body>
    <div id="container">
        <!-- 하나의 패널로 합친 컨트롤 -->
        <div id="controls">
            <input type="file" id="image-input" accept="image/*" />
            <label>높이 배율: 
                <input type="range" id="height-scale" min="0.1" max="5" step="0.1" value="1">
            </label>
            
            <!-- 색상 모드 관련 라디오 그룹 -->
            <div>
                <div style="font-weight: bold;">색상 모드:</div>
                <div>
                    <input type="radio" id="color-mode-none" name="color-mode" value="none">
                    <label for="color-mode-none">단색</label>
                </div>
                <div>
                    <input type="radio" id="color-mode-vertex" name="color-mode" value="vertex">
                    <label for="color-mode-vertex">이미지 색상 (Vertex)</label>
                </div>
                <div>
                    <input type="radio" id="color-mode-diffuse" name="color-mode" value="diffuse" checked>
                    <label for="color-mode-diffuse">이미지 색상 (Diffuse)</label>
                </div>
            </div>
            
            <!-- 원본 이미지 / 그림자 토글 -->
            <button id="toggle-image">원본 이미지 보기</button>
            <button id="toggle-shadows">그림자 켜기/끄기</button>

            <!-- 빛 위치 -->
            <div style="margin-top:10px;">
                <div style="font-weight: bold;">빛 위치:</div>
                <div class="position-control">
                    <label>X:</label>
                    <input type="range" id="light-x" min="-100" max="100" step="1" value="50">
                    <span id="light-x-value" class="position-value">50</span>
                </div>
                <div class="position-control">
                    <label>Y:</label>
                    <input type="range" id="light-y" min="0" max="100" step="1" value="50">
                    <span id="light-y-value" class="position-value">50</span>
                </div>
                <div class="position-control">
                    <label>Z:</label>
                    <input type="range" id="light-z" min="-100" max="100" step="1" value="50">
                    <span id="light-z-value" class="position-value">50</span>
                </div>
                <button id="reset-light">빛 위치 초기화</button>
            </div>
        </div>

        <div id="scene-container"></div>
        <img id="original-image" alt="원본 이미지">
        <div id="debug-info">디버그 정보: 준비중...</div>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        class VoxelHeightMapRenderer {
            constructor() {
                // 기본 설정
                this.heightScale = 1.5;
                this.usePixelColors = true;
                this.colorMode = 'diffuse'; // 'none', 'vertex', 'diffuse'

                // 아래 값들은 제거된 슬라이더가 없어도 기본값을 계속 사용
                // (사용자 제어는 안 하지만 광원 자체 기능/반사 기능은 유지)
                this.baseColor = 0xffffff;
                this.shadowsEnabled = true;
                this.showingOriginalImage = false;
                this.maxVoxels = 8000; // 고정값 (UI 컨트롤 제거)

                // 광원 기본값
                this.lightIntensity = 1;
                this.lightColor = new THREE.Color(1, 1, 1);
                this.lightPosition = new THREE.Vector3(50, 50, 50);
                this.ambientIntensity = 0.2;
                this.specularIntensity = 0.5;
                this.shininess = 30;

                // 디버그 정보
                this.debugElement = document.getElementById('debug-info');

                // Three.js 초기화
                this.init();

                // 이벤트 리스너 설정
                this.initEvents();

                // 바닥 그리드
                this.addGrid();

                // 애니메이션
                this.animate();

                // 기본 이미지 로드
                this.loadDefaultImage();
            }

            loadDefaultImage() {
                console.log("기본 이미지 로드 시도 중...");
                const img = new Image();

                img.onload = () => {
                    console.log("이미지 로드 성공:", img.width, "x", img.height);

                    document.getElementById('original-image').src = img.src;

                    const canvas = document.createElement('canvas');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(img, 0, 0);

                    this.imageData = ctx.getImageData(0, 0, img.width, img.height);

                    // 복셀 맵 렌더링
                    this.renderVoxelMap();

                    // 카메라/빛 조정
                    this.adjustCameraAndLightToImage(img.width, img.height);

                    this.updateDebugInfo(`초기 이미지 로드 완료: ${img.width}x${img.height} 픽셀`);
                };

                img.onerror = (err) => {
                    console.error("이미지 로드 실패:", err);
                    this.updateDebugInfo("초기 이미지 로드 실패");
                };

                // 샘플용 기본 이미지 경로
                img.src = '0.png';
                console.log("이미지 소스 설정됨:", img.src);
            }

            updateDebugInfo(message) {
                if (this.debugElement) {
                    this.debugElement.textContent = `디버그 정보: ${message}`;
                }
                console.log(message);
            }

            init() {
                // 씬 생성
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x222222);

                // 카메라
                this.camera = new THREE.PerspectiveCamera(
                    60, window.innerWidth / window.innerHeight, 0.1, 1000
                );
                this.camera.position.set(50, 50, 50);

                // 렌더러
                this.renderer = new THREE.WebGLRenderer({ antialias: true });
                this.renderer.setSize(window.innerWidth, window.innerHeight);
                this.renderer.setPixelRatio(window.devicePixelRatio);
                this.renderer.shadowMap.enabled = this.shadowsEnabled;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;

                document.getElementById('scene-container').appendChild(this.renderer.domElement);

                // 컨트롤
                this.controls = new OrbitControls(this.camera, this.renderer.domElement);
                this.controls.enableDamping = true;
                this.controls.dampingFactor = 0.05;

                // 조명
                this.setupLighting();

                // 복셀 그룹
                this.voxels = new THREE.Group();
                this.scene.add(this.voxels);

                // 리사이즈 대응
                window.addEventListener('resize', () => this.onWindowResize());

                this.updateDebugInfo("초기화 완료");
            }

            initEvents() {
                // 이미지 입력
                document.getElementById('image-input').addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadImage(file);
                    }
                });

                // 높이 배율
                document.getElementById('height-scale').addEventListener('input', (e) => {
                    this.heightScale = parseFloat(e.target.value);
                    this.renderVoxelMap();
                });

                // 색상 모드 라디오
                document.querySelectorAll('input[name="color-mode"]').forEach(radio => {
                    radio.addEventListener('change', (e) => {
                        this.colorMode = e.target.value;
                        this.renderVoxelMap();
                    });
                });

                // 원본 이미지 토글
                document.getElementById('toggle-image').addEventListener('click', () => {
                    this.showingOriginalImage = !this.showingOriginalImage;
                    document.getElementById('original-image').style.display =
                        this.showingOriginalImage ? 'block' : 'none';
                });

                // 그림자 토글
                document.getElementById('toggle-shadows').addEventListener('click', () => {
                    this.shadowsEnabled = !this.shadowsEnabled;
                    this.renderer.shadowMap.enabled = this.shadowsEnabled;
                    this.directionalLight.castShadow = this.shadowsEnabled;
                    this.renderVoxelMap();
                });

                // 빛 위치 (X, Y, Z)
                ['x', 'y', 'z'].forEach(axis => {
                    document.getElementById(`light-${axis}`).addEventListener('input', (e) => {
                        this.lightPosition[axis] = parseFloat(e.target.value);
                        document.getElementById(`light-${axis}-value`).textContent = e.target.value;
                        this.updateLightPosition();
                    });
                });

                // 빛 위치 초기화
                document.getElementById('reset-light').addEventListener('click', () => {
                    if (this.imageData) {
                        const { width, height } = this.imageData;
                        this.lightPosition.set(width / 2, height / 2, height / 2);
                    } else {
                        this.lightPosition.set(50, 50, 50);
                    }
                    this.updateLightPositionUI();
                    this.updateLightPosition();
                });
            }

            setupLighting() {
                // 앰비언트 라이트
                this.ambientLight = new THREE.AmbientLight(0xffffff, this.ambientIntensity);
                this.scene.add(this.ambientLight);

                // 방향성 광원
                this.directionalLight = new THREE.DirectionalLight(this.lightColor, this.lightIntensity);
                this.directionalLight.position.copy(this.lightPosition);
                this.directionalLight.castShadow = this.shadowsEnabled;

                // 그림자 품질
                this.directionalLight.shadow.mapSize.width = 2048;
                this.directionalLight.shadow.mapSize.height = 2048;
                this.directionalLight.shadow.camera.near = 0.5;
                this.directionalLight.shadow.camera.far = 1000;
                this.directionalLight.shadow.bias = -0.0001;
                this.scene.add(this.directionalLight);

                // 빛 헬퍼(작은 구체)
                this.lightHelper = new THREE.Mesh(
                    new THREE.SphereGeometry(2, 16, 16),
                    new THREE.MeshBasicMaterial({ color: 0xffff00 })
                );
                this.lightHelper.position.copy(this.lightPosition);
                this.scene.add(this.lightHelper);

                this.updateLightPositionUI();
            }

            updateLightPositionUI() {
                ['x', 'y', 'z'].forEach(axis => {
                    const slider = document.getElementById(`light-${axis}`);
                    const valueDisplay = document.getElementById(`light-${axis}-value`);
                    if (slider && valueDisplay) {
                        slider.value = this.lightPosition[axis];
                        valueDisplay.textContent = Math.round(this.lightPosition[axis]);
                    }
                });
            }

            updateLightPosition() {
                this.directionalLight.position.copy(this.lightPosition);
                this.lightHelper.position.copy(this.lightPosition);

                if (this.imageData) {
                    const { width, height } = this.imageData;
                    const size = Math.max(width, height) * 1.5;
                    this.directionalLight.shadow.camera.left = -size / 2;
                    this.directionalLight.shadow.camera.right = size / 2;
                    this.directionalLight.shadow.camera.top = size / 2;
                    this.directionalLight.shadow.camera.bottom = -size / 2;
                    this.directionalLight.shadow.camera.updateProjectionMatrix();
                }
            }

            loadImage(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        const width = img.width;
                        const height = img.height;

                        const canvas = document.createElement('canvas');
                        canvas.width = width;
                        canvas.height = height;
                        const ctx = canvas.getContext('2d');
                        ctx.drawImage(img, 0, 0, width, height);

                        this.imageData = ctx.getImageData(0, 0, width, height);

                        document.getElementById('original-image').src = URL.createObjectURL(file);

                        this.renderVoxelMap();
                        this.adjustCameraAndLightToImage(width, height);
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            adjustCameraAndLightToImage(width, height) {
                const maxDim = Math.max(width, height);
                this.camera.position.set(width * 0.6, maxDim * 0.9, height * 0.8);
                this.lightPosition.set(width / 2, maxDim, height / 2);
                this.updateLightPosition();
                this.updateLightPositionUI();

                this.controls.target.set(width * 0.5, 0, height * 0.7);
                this.controls.update();

                this.updateDebugInfo(`이미지 로드 완료: ${width}x${height} 픽셀`);
            }

            renderVoxelMap() {
                while (this.voxels.children.length > 0) {
                    const child = this.voxels.children[0];
                    if (child.geometry) child.geometry.dispose();
                    if (child.material) {
                        if (Array.isArray(child.material)) {
                            child.material.forEach(m => m.dispose());
                        } else {
                            child.material.dispose();
                        }
                    }
                    this.voxels.remove(child);
                }

                if (!this.imageData) return;
                this.updateDebugInfo("복셀 맵 렌더링 중...");

                const { width, height, data } = this.imageData;
                const totalVoxels = width * height;
                const step = Math.ceil(Math.sqrt(totalVoxels / this.maxVoxels)) > 1
                    ? Math.ceil(Math.sqrt(totalVoxels / this.maxVoxels))
                    : 1;

                const boxGeometry = new THREE.BoxGeometry(1, 1, 1);

                switch(this.colorMode) {
                    case 'none':
                        this.currentMaterial = new THREE.MeshPhongMaterial({
                            color: this.baseColor,
                            vertexColors: false,
                            shininess: this.shininess,
                            specular: new THREE.Color(
                                this.specularIntensity,
                                this.specularIntensity,
                                this.specularIntensity
                            )
                        });
                        break;
                    case 'vertex':
                        this.currentMaterial = new THREE.MeshPhongMaterial({
                            color: 0xffffff,
                            vertexColors: true,
                            shininess: this.shininess,
                            specular: new THREE.Color(
                                this.specularIntensity,
                                this.specularIntensity,
                                this.specularIntensity
                            )
                        });
                        break;
                    case 'diffuse':
                        this.renderDiffuseColorMap(width, height, data, step, this.maxVoxels);
                        return;
                }

                const instancedMesh = new THREE.InstancedMesh(
                    boxGeometry,
                    this.currentMaterial,
                    Math.min(this.maxVoxels, Math.ceil(totalVoxels / (step * step)))
                );

                instancedMesh.castShadow = this.shadowsEnabled;
                instancedMesh.receiveShadow = this.shadowsEnabled;

                const dummy = new THREE.Object3D();
                let instanceIdx = 0;

                for (let z = 0; z < height; z += step) {
                    for (let x = 0; x < width; x += step) {
                        if (instanceIdx >= this.maxVoxels) break;
                        const pixelIndex = (z * width + x) * 4;
                        const r = data[pixelIndex];
                        const g = data[pixelIndex + 1];
                        const b = data[pixelIndex + 2];
                        const a = data[pixelIndex + 3];
                        if (a < 128) continue;
                        const grayscale = (r + g + b) / 3 / 255;
                        const voxelHeight = Math.max(grayscale * 30 * this.heightScale, 0.1);

                        dummy.position.set(x, voxelHeight / 2, z);
                        dummy.scale.set(step, voxelHeight, step);
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(instanceIdx, dummy.matrix);

                        if (this.colorMode === 'vertex') {
                            const color = new THREE.Color(r / 255, g / 255, b / 255);
                            instancedMesh.setColorAt(instanceIdx, color);
                        }
                        instanceIdx++;
                    }
                }

                instancedMesh.instanceMatrix.needsUpdate = true;
                if (instancedMesh.instanceColor) instancedMesh.instanceColor.needsUpdate = true;
                this.voxels.add(instancedMesh);

                this.addGroundPlane(width, height);
                this.updateDebugInfo(`렌더링 완료: ${instanceIdx} 복셀, 모드: ${this.colorMode}`);
            }

            renderDiffuseColorMap(width, height, data, step) {
                let voxelCount = 0;
                const voxelGroup = new THREE.Group();

                for (let z = 0; z < height; z += step) {
                    for (let x = 0; x < width; x += step) {
                        if (voxelCount >= this.maxVoxels) break;
                        const pixelIndex = (z * width + x) * 4;
                        const r = data[pixelIndex];
                        const g = data[pixelIndex + 1];
                        const b = data[pixelIndex + 2];
                        const a = data[pixelIndex + 3];
                        if (a < 128) continue;

                        const grayscale = (r + g + b) / 3 / 255;
                        const voxelHeight = Math.max(grayscale * 30 * this.heightScale, 0.1);
                        const voxelColor = new THREE.Color(r / 255, g / 255, b / 255);

                        const material = new THREE.MeshPhongMaterial({
                            color: voxelColor,
                            shininess: this.shininess,
                            specular: new THREE.Color(
                                this.specularIntensity,
                                this.specularIntensity,
                                this.specularIntensity
                            )
                        });

                        const geometry = new THREE.BoxGeometry(step, voxelHeight, step);
                        const voxel = new THREE.Mesh(geometry, material);
                        voxel.position.set(x, voxelHeight / 2, z);

                        voxel.castShadow = this.shadowsEnabled;
                        voxel.receiveShadow = this.shadowsEnabled;

                        voxelGroup.add(voxel);
                        voxelCount++;
                        if (voxelCount % 100 === 0) {
                            this.updateDebugInfo(`복셀 생성 중: ${voxelCount}/${this.maxVoxels}`);
                        }
                    }
                }

                this.voxels.add(voxelGroup);
                this.addGroundPlane(width, height);
                this.updateDebugInfo(`디퓨즈 색상 모드 렌더링 완료: ${voxelCount} 복셀`);
            }

            addGroundPlane(width, height) {
                const planeGeometry = new THREE.PlaneGeometry(width + 20, height + 20);
                const planeMaterial = new THREE.MeshPhongMaterial({ 
                    color: 0xaaaaaa,
                    shininess: 30,
                    specular: new THREE.Color(0.2, 0.2, 0.2)
                });
                const plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.position.set(width / 2, -0.5, height / 2);
                plane.receiveShadow = this.shadowsEnabled;
                this.voxels.add(plane);
            }

            animate() {
                requestAnimationFrame(() => this.animate());
                this.controls.update();
                this.renderer.render(this.scene, this.camera);
            }

            onWindowResize() {
                this.camera.aspect = window.innerWidth / window.innerHeight;
                this.camera.updateProjectionMatrix();
                this.renderer.setSize(window.innerWidth, window.innerHeight);
            }
        }

        window.addEventListener('DOMContentLoaded', () => {
            console.log("DOM 로드 완료, 렌더러 초기화");
            window.voxelRenderer = new VoxelHeightMapRenderer();
        });
    </script>
</body>
</html>
